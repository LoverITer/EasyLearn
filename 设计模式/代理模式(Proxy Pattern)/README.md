### 代理模式(Proxy Pattern)



### 一、代理模式的定义

**代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能**，这是它跟装饰器模式最大的不同。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。

静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们无需事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。

### 二、代理模式的优点

#### 优点：

1. **职责清晰**：代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
2. **高扩展性**：代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性
3. **智能化**：代理对象可以扩展并增强目标对象的功能

#### 缺点：

1. 由于在客户端和真实主题之间增加了代理对象，会造成请求的处理速度变慢。 
2. 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

### 三、代理模式的应用用场景

当直接访问对象会带来问题时，比如：要访问的对象在远程的机器上、在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。

**应用实例**：

1. **Spring 框架中的AOP机制**：使用到了代理模式的一个变种：动态代理，这也是实际生产中应用最多的一种模式，基于Spring AOP我们可以实现业务系统中的一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，这样程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。
2. **Windows 里面的快捷方式**：我们在Win桌面看到的应用图标其实只是一个指向安装程序路径的代理，我们点击这个图标实际是在启动他指向的`.exe` 文件。
3. **”翻墙软件“的代理服务器**：我们无法直接访问到境外网站，这时我们需要一个中间角色来帮我们从目标服务器拿到数据后返回给我们，这个中间角色就是代理服务器。
4. **图片代理**：在Web中浏览大图一般使用图片代理实现，即用户访问某大图时不是直接加载该图片，这样会很消耗网络带宽，而是采用先向客户端浏览器加载一个小图，然后在后台加载大图，这样可以大幅度提升用户体验。
5. **虚拟代理**：虚拟代理模式是一种内存节省技术，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。

还有很多应用案例，可以说，代理模式无论在生活上还是在程序开发日常里，实在是太常见了！

### 四、 代理模式的通用类图

<img src="http://image.easyblog.top/1-0-5783191-5783193.png" style="width:55%;" />

* **抽象角色(Subject)**：通过接口或抽象类声明真实角色实现的业务方法。

* **代理角色(Proxy)**：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。

* **真实角色(RealSubject)**：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。

### 五、代理模式的通用实现

我们平常去电影院看电影的时候，在电影开始的阶段是不是经常会放广告呢？

电影是电影公司委托给影院进行播放的，但是影院可以在播放电影的时候，产生一些自己的经济收益，比如卖爆米花、可乐等，然后在影片开始结束时播放一些广告。

现在用代码来进行模拟。

首先得有一个接口，通用的接口是代理模式实现的基础。这个接口我们命名为 Movie，代表电影播放的能力。

```java
public interface Movie{
    void play();
}
```

然后，我们要有一个真正的实现这个 Movie 接口的类，和一个只是实现接口的代理类。

```java
public class RealMovie implements Movie{
  
   private String movieName;
  
   public RealMovie(String movieName){
     this.movieName=movieName;
   }

    @Override
    public void play(){
        System.out.println("播放电影:"+movieName);
    }
}
```

这个类实现了Movie接口的play方法，只要调用就可以播放，接下来还需要一个代理类来代理这个”电影“

```java
public class RealMovieProxy implements Movice{
  
    private Movie movie;

    public RealMovieProxy(Movie movie){
        this.movie=movie;
    }

    @Override
    public void play(){
        System.out.println("电影马上开始了，爆米花、可乐、口香糖9.8折，快来买啊！");
        System.out.println("播放广告...");
        movie.play();
        System.out.println("电影马上结束了，爆米花、可乐、口香糖5折，买回家吃吧！");
    }

}
```

这里的RealMovieProxy就是一个代理类它有一个 play() 方法。不过调用 play() 方法时，它对原有的播放电影这件事进行了增强—即插入了广告。现在，测试一下：

```java
public class Client{

    public static void main(String[] args){
        RealMovie movie=new RealMovie("速度与激情9");
        RealMovieProxy proxy=new RealMovieProxy(movie);
        proxy.play();
    }

}
```

执行结果：

![](http://image.easyblog.top/%E6%88%AA%E5%B1%8F2022-03-02%20%E4%B8%8B%E5%8D%886.53.55.png)

从执行的结果可以看到，**代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。**

上面这种代理方式因为它的类型是我们程序员或接助工具事先预定好的，比如上面代码中的 RealMovieProxy 这个类。所以他被称为**静态代理模式**。其实代理模式真正在生产中使用最多的是**动态代理**，有关内容请跳转到[透过代理模式探究JAVA中的动态代理](https://www.easyblog.top/article/details/238)一文，感兴趣的小伙伴可以追一波~

